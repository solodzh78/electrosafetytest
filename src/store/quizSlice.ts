import { createAsyncThunk, createSlice, PayloadAction } from "@reduxjs/toolkit";
import { fetchLocalQuiz } from "../api/quizAPI";

export const fetchQuiz = createAsyncThunk(
    "quiz/fetchQuiz",
    async (_, { rejectWithValue }) => {
        try {
            const res = await fetchLocalQuiz();
            console.log('res: ', res);
            return res.data;
        } catch (error: any) {
            return rejectWithValue(error.message);
        }
    }
);

interface ISetSelectedAnswerPayload {
	cardNumber: number,
	selectedAnswer: number
}

export interface IQuizState {
    quiz:{
			id: number,
			question: string,
			answers: string[],
			correctAnswer: number,
			selectedAnswer?: number
		}[] | [],
    status: "idle" | "loading" | "failed";
    error: [];
}

const initialState: IQuizState = {
    quiz: [],
    status: "idle",
    error: [],
};

export const quizSlice = createSlice({
    name: "quiz",
    initialState,
    // The `reducers` field lets us define reducers and generate associated actions
    // Поле «редьюсеры» позволяет нам определять редьюсеры и генерировать связанные действия.
    reducers: {
        // increment: (state) => {
        // Redux Toolkit allows us to write "mutating" logic in reducers. It
        // doesn't actually mutate the state because it uses the Immer library,
        // which detects changes to a "draft state" and produces a brand new
        // immutable state based off those changes
        // Redux Toolkit позволяет нам писать «мутирующую» логику в редюсерах.
        // На самом деле он не изменяет состояние, потому что использует библиотеку Immer,
        // которая обнаруживает изменения в «черновом состоянии» и создает совершенно новое
        // неизменное состояние на основе этих изменений.
        //     state.value += 1;
        // },
        // decrement: (state) => {
        //     state.value -= 1;
        // },
        // Use the PayloadAction type to declare the contents of `action.payload`
        // Используйте тип PayloadAction для объявления содержимого action.payload.

        setSelectedAnswer: (
            state,
            action: PayloadAction<ISetSelectedAnswerPayload>
        ) => {
            const { cardNumber, selectedAnswer } = action.payload;
            if (state.quiz)
                state.quiz[cardNumber - 1].selectedAnswer = selectedAnswer;
        },
    },
    // The `extraReducers` field lets the slice handle actions defined elsewhere,
    // including actions generated by createAsyncThunk or in other slices.
    // Поле `extraReducers` позволяет срезу обрабатывать действия, определенные в другом месте,
    // включая действия, созданные createAsyncThunk или в других срезах.

    extraReducers: (builder) => {
        builder
            .addCase(fetchQuiz.pending, (state) => {
                state.status = "loading";
            })
            .addCase(
                fetchQuiz.fulfilled,
                (state, action) => {
                    state.status = "idle";
                    state.quiz = action.payload;
                    console.log("action.payload: ", action.payload);
                }
            )
            .addCase(fetchQuiz.rejected, (state, action) => {
                state.status = "failed";
            });
    },
});


export const { setSelectedAnswer } = quizSlice.actions;

/* The function below is called a selector and allows us to select a value from
the state. Selectors can also be defined inline where they're used instead of
in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
Приведенная ниже функция называется селектором и позволяет нам выбирать значение из состояния. 
Селекторы также могут быть определены внутри файла, где они используются, а не в файле слайса. 
Например: `useSelector((state: RootState) => state.counter.value)`
export const selectCount = (state: RootState) => state.counter.value;

We can also write thunks by hand, which may contain both sync and async logic.
Here's an example of conditionally dispatching actions based on current state.
Мы также можем вручную написать переходники, которые могут содержать как синхронную, так и асинхронную логику. 
Вот пример условной отправки действий на основе текущего состояния.
 */
/* export const incrementIfOdd =
    (amount: number): AppThunk =>
    (dispatch, getState) => {
        const currentValue = selectCount(getState());
        if (currentValue % 2 === 1) {
            dispatch(incrementByAmount(amount));
        }
    }; */

export default quizSlice.reducer;
